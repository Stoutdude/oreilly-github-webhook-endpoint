<!DOCTYPE html><html lang="en"><head><title>lib/github-bridge</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="lib/github-bridge"><meta name="groc-project-path" content="lib/github-bridge.js"><meta name="groc-github-url" content="https://github.com/deliciousinsights/oreilly-github-webhook-endpoint"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/deliciousinsights/oreilly-github-webhook-endpoint/blob/master/lib/github-bridge.js">lib/github-bridge.js</a></div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><h1 id="github-api-bridge">GitHub API Bridge</h1></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>We mostly rely on <a href="https://github.com/mikedeboer/node-github">node-github</a>
(<code>github</code> on npm) to wrap our accesses to GitHub’s API, but sometimes this
wrapper is a bit too low-level / basic, or outright doesn&#39;t feature extra
helpers we need (such as specific user-facing GitHub URLs), so we wrapped that
with an extra layer more amenable to this demo app&#39;s business needs.</p>
<p>This also has the great advantage of keeping all the API-related code into
this single module, including persistent state such as GitHub App credentials,
OAuth access token, and webhook secret token.  Far less coupling across
controllers, for instance.</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode">Strict mode</a> is always a good idea.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-pi">'use strict'</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>eslint complexity: [2, 10] </p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="modules-we-need-in-this-file">Modules we need in this file</h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This loads both third-party (from <a href="http://npmjs.com/">npm</a>) and local stuff (paths starting with <code>../</code>).</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> <span class="hljs-keyword">async</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'async'</span>)
<span class="hljs-keyword">var</span> dotenv = <span class="hljs-built_in">require</span>(<span class="hljs-string">'dotenv'</span>)
<span class="hljs-keyword">var</span> getBody = <span class="hljs-built_in">require</span>(<span class="hljs-string">'raw-body'</span>)
<span class="hljs-keyword">var</span> GitHub = <span class="hljs-built_in">require</span>(<span class="hljs-string">'github'</span>)
<span class="hljs-keyword">var</span> hmacSha1 = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../lib/hmac-sha1'</span>)
<span class="hljs-keyword">var</span> qs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'querystring'</span>)
<span class="hljs-keyword">var</span> request = <span class="hljs-built_in">require</span>(<span class="hljs-string">'superagent'</span>)
<span class="hljs-keyword">var</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">'util'</span>)
<span class="hljs-keyword">var</span> verifySignature = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../lib/verify-signature'</span>)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The <a href="https://developer.github.com/v3/oauth/#scopes">OAuth scopes</a>
we&#39;re going to need for this service.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> REQUESTED_SCOPES = <span class="hljs-string">'repo'</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A cryptographically-secure random secret token we can use
(unless it&#39;s overridden by a persistent one stored in <code>.env</code>)
for securing our incoming webhook event requests from GitHub.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> SECRET_TOKEN = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>).randomBytes(<span class="hljs-number">32</span>).toString(<span class="hljs-string">'hex'</span>)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="github-credentials-and-api-wrapper">GitHub credentials and API wrapper</h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This will store a number of credentials (App&#39;s client ID, App&#39;s client
secret, access token, persistent secret token) and the callback URL
for this instance of the app (port may change across launches).</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> credentials = {}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The main GitHub API wrapper.  A singleton used by all higher-level
functions exposed by this module.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> github = <span class="hljs-keyword">new</span> GitHub({
  version: <span class="hljs-string">'3.0.0'</span>,
  headers: { <span class="hljs-string">'User-Agent'</span>: <span class="hljs-string">'OReilly-GitHub-Training-DemoServer/1.0'</span> },
  timeout: <span class="hljs-number">5000</span>
})</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>We immediately load and verify our credentials, at module init time,
therefore at server startup time.  See the function below (it&#39;s callable
from right here because of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function#Function_declaration_hoisting">JS function declaration hoisting</a>).</p></div></div><div class="code"><div class="wrapper">loadCredentials()</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="token-validity-check">Token validity check</h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Core function for checking that a known access token is still valid.
The API wrapper has not call for this, so we manually call the API
URL for it, using our app&#39;s client ID and the token itself, server-to-server,
with proper HTTP Basic Authentication credentials.  That call does not
impact our API Rate Limit consumption.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkToken</span> (<span class="hljs-params">callback</span>) </span>{
  <span class="hljs-keyword">var</span> url = <span class="hljs-string">'https://api.github.com/applications/'</span> + credentials.clientId +
    <span class="hljs-string">'/tokens/'</span> + credentials.accessToken
  request
    .get(url)
    .auth(credentials.clientId, credentials.clientSecret)
    .end(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, saResponse</span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Common pattern when manually requesting an API URL: we could get an
HTTP-level error in <code>err</code>, or a business-logic API error, described
in the response body&#39;s <code>error</code>, <code>error_description</code> and <code>error_uri</code>
fields.  Standardize this for our callback.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">var</span> hasError = err || saResponse.body.error
      <span class="hljs-keyword">var</span> error = hasError ? <span class="hljs-built_in">String</span>(err || saResponse.body.error_description) : <span class="hljs-literal">null</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>When the token check works, we display the token&#39;s details on the
server console, just FYI.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> (!hasError) {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'==== TOKEN CHECK RESPONSE ===='</span>.green)
        <span class="hljs-built_in">console</span>.log(util.inspect(saResponse.body, { colors: <span class="hljs-literal">true</span> }))
      }

      callback(error)
    })
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="webhook-setup">Webhook Setup</h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Creates a new webhook for our service in the repo identified by <code>params</code>.
Because our URL keeps changing as we re-launch <code>ngrok</code>, we can&#39;t quite
list existing hooks to reliably determine whether we already have one.</p>
<p>We could avoid duplicates by storing the hook&#39;s ID server-side (say,
in a simple <a href="https://github.com/typicode/lowdb">lowDB</a> database) and then
use that to either create or update our hook, but that&#39;s, as they say,
“left as an exercise for the reader.”</p></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createHook</span> (<span class="hljs-params">params, callback</span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>In GitHub parlance, &quot;nwo&quot; stands for “name with owner”, and you&#39;ll usually
find it in GitHub API payloads as <code>full_name</code> fields in repository objects.
It&#39;s easier to lug around than two individual fields, but GitHub API calls
insist on identifying repos with two separate fields, <code>user</code> and <code>repo</code>, so
we make it easy on our callers and adjust internally.  You&#39;ll find this
pattern in several places throughout this codebase.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> repo = params.nwo.split(<span class="hljs-string">'/'</span>)
  <span class="hljs-keyword">var</span> payload = {
    user: repo[<span class="hljs-number">0</span>],
    repo: repo[<span class="hljs-number">1</span>],</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Webhooks <em>have</em> to use <code>&#39;web&#39;</code> as a <code>name</code>.</p></div></div><div class="code"><div class="wrapper">    name: <span class="hljs-string">'web'</span>,
    config: {
      url: params.url,
      content_type: <span class="hljs-string">'json'</span>,
      secret: SECRET_TOKEN
    },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>We&#39;re only interested in <code>pull_request</code> events anyway, so…</p></div></div><div class="code"><div class="wrapper">    events: [<span class="hljs-string">'pull_request'</span>],</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Webhooks are active by default, but it doesn&#39;t hurt to be explicit.</p></div></div><div class="code"><div class="wrapper">    active: <span class="hljs-literal">true</span>
  }
  github.repos.createHook(payload, callback)
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="configuration">Configuration</h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Tiny configuration method used by the main server to give us our
actual local URL, so we can compute our callback URL from it and
use that when authorizing (see <code>getAuthorizationURL()</code>).</p></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">configure</span> (<span class="hljs-params">options</span>) </span>{
  credentials.callbackURL = options.rootURL + <span class="hljs-string">'/oauth/callback'</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="oauth-web-flow-final-step">OAuth Web Flow, Final Step</h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>When the end-user authorizes us, GitHub calls back to us in the browser,
with a one-time, quick-expiry authorization code.  We then call their API
internally to obtain the actual access token for it, which is what we&#39;ll
be using for later API calls on behalf of our end-user.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exchangeAuthCodeForToken</span> (<span class="hljs-params">authCode, callback</span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The API wrapper has not call for this, so we manually call the API
URL for it, using our app&#39;s credentials and the authorization code.</p></div></div><div class="code"><div class="wrapper">  request
    .post(<span class="hljs-string">'https://github.com/login/oauth/access_token'</span>)
    .send({
      client_id: credentials.clientId,
      client_secret: credentials.clientSecret,
      code: authCode
    })
    .end(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, saResponse</span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>For details about this error standardization pattern, see the same
code above in <code>checkToken()</code>.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">var</span> hasError = err || saResponse.body.error
      <span class="hljs-keyword">var</span> error = hasError ? <span class="hljs-built_in">String</span>(err || saResponse.body.error_description) : <span class="hljs-literal">null</span>

      <span class="hljs-keyword">if</span> (!hasError) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Store the OAuth access token (in-memory) for later uses</p></div></div><div class="code"><div class="wrapper">        credentials.accessToken = saResponse.body.access_token</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Switch the GitHub API wrapper authentication to use this
access token from now on.</p></div></div><div class="code"><div class="wrapper">        github.authenticate({
          type: <span class="hljs-string">'oauth'</span>,
          token: credentials.accessToken
        })</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Log details about the token on the server console, FYI.</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\\o/ Got our access token:'</span>.green, credentials.accessToken.cyan)
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">' (normalized scopes: %s)'</span>.gray, saResponse.body.scope)
      }

      callback(error)
    })
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="authorization-url">Authorization URL</h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Public helper function to compute the OAuth Web Flow initial URL
(step1: request authorization) for our app, based on our credentials,
requested scopes, and local callback URL.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAuthorizationURL</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">'https://github.com/login/oauth/authorize?'</span> + qs.stringify({
    client_id: credentials.clientId,
    redirect_uri: credentials.callbackURL,
    scope: REQUESTED_SCOPES
  })
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="commits-in-a-pull-request">Commits in a Pull Request</h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Public helper function for the CI service to obtain the commits
involved in a given pull request, identified by its repo&#39;s <code>nwo</code>
and pull request <code>number</code>.  Will not paginate, but return up to
100 commits (auto-pagination is another nice feature that the
<code>github</code> wrapper module doesn&#39;t offer, sigh…).</p></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCommitsForPullRequest</span> (<span class="hljs-params">params, callback</span>) </span>{
  <span class="hljs-keyword">var</span> nwo = params.nwo.split(<span class="hljs-string">'/'</span>)
  github.pullRequests.getCommits({
    user: nwo[<span class="hljs-number">0</span>],
    repo: nwo[<span class="hljs-number">1</span>],
    number: params.number,
    per_page: <span class="hljs-number">100</span>
  }, callback)
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="list-user-accessible-repositories">List user-accessible repositories</h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Public helper function to list the repositories the end-user
identified by our access token has write access to (so we can
pick one to setup our webhook on).</p></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRepositories</span> (<span class="hljs-params">callback</span>) </span>{
  github.repos.getAll({ per_page: <span class="hljs-number">100</span> }, callback)
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="permissions-review-url">Permissions review URL</h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Public helper function to compute the permissions review URL
for our application in the end-user&#39;s GitHub account.  GitHub
<a href="https://developer.github.com/v3/oauth/#directing-users-to-review-their-access-for-an-application">encourages integrators</a>
to ease the end-user&#39;s review ability of the granted permissions
for our service.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getReviewURL</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">'https://github.com/settings/connections/applications/'</span> +
    credentials.clientId
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="authentication-status">Authentication status</h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Public helper function to determine whether we have authenticated
successfully (we have a known OAuth access token) and can therefore
start using the API, or not.  Useful for toggling the proposed actions
on the homepage.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isAuthenticated</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> !!credentials.accessToken
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="webhook-event-payload-verification">Webhook event payload verification</h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Incoming webhook event requests may be counterfeited by malicious
entities.  To secure your webhook, GitHub recommends providing a
secure, unique <a href="https://developer.github.com/webhooks/securing/">secret token</a>
for your webhooks.  When such a token is there, GitHub will cryptographically
sign all its matching requests with it, using a well-known mechanism
called an <a href="https://en.wikipedia.org/wiki/Hash-based_message_authentication_code">HMAC-SHA1</a>
signature.</p>
<p>Our webhook server code can then retrieve that signature along with the
request&#39;s payload, compute the signature itself, and verify that its signature
and the sender&#39;s match.</p>
<p>This public function does that, automatically sets up the HTTP response
(<code>res</code>) if verification fails, and if it succeeds pre-parses the request
body&#39;s JSON payload.  It also augments the returned data with event
identification data, such as event type and delivery ID, which are only
available from <a href="https://developer.github.com/webhooks/#delivery-headers">specific HTTP request headers</a>.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadAndVerifyWebhookEventPayload</span> (<span class="hljs-params">req, res, callback</span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>We use <a href="https://github.com/caolan/async">Async.js</a> again to
asynchronously compute the body&#39;s signature <strong>and</strong> grab the body&#39;s
full text, in parallel.  This is the kind of stuff Node.js really shines
at, and that would be quite difficult, if not outright impossible, in
many other server technologies.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">async</span>.parallel([</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>1a. Compute the HMAC-SHA1 signature of the entire body (payload)</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cb</span>) </span>{ hmacSha1(req, SECRET_TOKEN, cb) },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>1b. Get the request&#39;s entire body from its stream</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cb</span>) </span>{ getBody(req, { encoding: <span class="hljs-string">'utf-8'</span> }, cb) }
  ],</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ol>
<li>Then handle the results</li>
</ol></div></div><div class="code"><div class="wrapper">  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, results</span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Error? Dang! Send the matching response back and be done.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (err) {
      res.status(err.status || <span class="hljs-number">500</span>).end(err.type || <span class="hljs-string">'Blam!'</span>)
      <span class="hljs-keyword">return</span> callback(err.status || <span class="hljs-number">500</span>)
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Display a delivery/event heading in the console (type and UUID)</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">var</span> eventType = req.headers[<span class="hljs-string">'x-github-event'</span>]
    <span class="hljs-keyword">var</span> deliveryId = req.headers[<span class="hljs-string">'x-github-delivery'</span>]
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'===== %s (%s) ====='</span>.yellow, eventType, deliveryId)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Verify signature based on secret token.
Deny with 403 (Forbidden) if incorrect.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">var</span> expectedSignature = results[<span class="hljs-number">0</span>]
    <span class="hljs-keyword">if</span> (!verifySignature(req, expectedSignature)) {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Invalid signature: denying request'</span>.red)
      res.status(<span class="hljs-number">403</span>).end(<span class="hljs-string">'Invalid signature: denying request.'</span>)
      <span class="hljs-keyword">return</span> callback(<span class="hljs-number">403</span>)
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Send the JSON payload back through the callback (unless it&#39;s
invalid JSON for some odd reason, then send the parse error back).</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">var</span> payload = <span class="hljs-built_in">JSON</span>.parse(results[<span class="hljs-number">1</span>])
      <span class="hljs-keyword">var</span> result = {
        eventType: eventType,
        deliveryId: deliveryId,
        payload: payload
      }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The <code>return</code>s below appease ESLint when it sees our code
call <code>callback</code> multiple times…</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">return</span> callback(<span class="hljs-literal">null</span>, result)
    } <span class="hljs-keyword">catch</span> (e) {
      <span class="hljs-keyword">return</span> callback(e)
    }
  })
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="startup-time-credential-loading">Startup-time credential loading</h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This is called directly from this module&#39;s init code (see way above),
which means it&#39;s called at startup time, as soon as this module is <code>require()</code>&#39;d.</p>
<p>All our credentials are expected to be made available through the process&#39;
environment, as per the <a href="">12-Factor Apps</a> Manifesto.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadCredentials</span> (<span class="hljs-params"></span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If not running in production mode, we do allow getting our credentials
from a non-versioned (<code>.gitignore</code>&#39;d) file, that we use to populate the
environment.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> productionMode = (process.env.NODE_ENV === <span class="hljs-string">'production'</span>)
  <span class="hljs-keyword">if</span> (!productionMode) {
    dotenv.load({ silent: <span class="hljs-literal">true</span> })
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Our registered <a href="https://github.com/settings/developers">Developer App</a>
has a fixed set of credentials: Client ID and Client Secret.  We need these.</p></div></div><div class="code"><div class="wrapper">  credentials.clientId = (process.env.CLIENT_ID || <span class="hljs-string">''</span>).trim()
  credentials.clientSecret = (process.env.CLIENT_SECRET || <span class="hljs-string">''</span>).trim()</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>In order to avoid our users having to re-authenticate through GitHub every
time they run this demo server, we also allow an <code>ACCESS_TOKEN</code> variable in
there.  This, of course, would make no sense in production: it would be stored,
hopefully encrypted asymetrically, in our database for individual user accounts.</p></div></div><div class="code"><div class="wrapper">  credentials.accessToken = (process.env.ACCESS_TOKEN || <span class="hljs-string">''</span>).trim()</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This is similar to the access token development-time issue.  This module
generates a new secret token at every run, but we allow our users to make it
fixed when playing with this demo, so they don&#39;t have to re-configure the
webhook at every run.  In production, the webhooks registered for the app
would be stored in the database, with at minimum their GitHub webhook ID and
their individual secret tokens.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> persistedSecret = (process.env.SECRET_TOKEN || <span class="hljs-string">''</span>).trim()
  <span class="hljs-keyword">if</span> (persistedSecret) {
    SECRET_TOKEN = persistedSecret
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Missing App credentials? Uh-oh, we can&#39;t do anything.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">if</span> (!credentials.clientId || !credentials.clientSecret) {
    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'/!\\ Missing GitHub app credentials in the environment.'</span>.red)
    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">' Make sure the environment has valid CLIENT_ID and CLIENT_SECRET variables'</span>.red)
    <span class="hljs-keyword">if</span> (!productionMode) {
      <span class="hljs-built_in">console</span>.error(<span class="hljs-string">' (you can put these in a non-versioned .env file at the root of this project)'</span>.gray)
    }
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'  (forgot to register this app?  Do it now --&gt; https://github.com/settings/developers)'</span>.gray)
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">''</span>)
    process.exit() <span class="hljs-comment">// eslint-disable-line no-process-exit</span>
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If we do have app credentials, we&#39;ll verify they&#39;re accurate/valid
by trying an API request to verify our Rate Limits: successfully authenticated
such requests have much higher limits.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'GitHub App credentials properly loaded. Checking them…'</span>.green)
  github.authenticate({
    type: <span class="hljs-string">'oauth'</span>,
    key: credentials.clientId,
    secret: credentials.clientSecret
  })
  github.misc.rateLimit({}, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, data</span>) </span>{
    <span class="hljs-keyword">if</span> (err) {
      <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'/!\\ Error when verifying GitHub App credentials'</span>.red, err)
      process.exit() <span class="hljs-comment">// eslint-disable-line no-process-exit</span>
    }

    <span class="hljs-keyword">if</span> (data.resources.core.limit &lt;= <span class="hljs-number">60</span>) {
      <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'/!\\ GitHub App credentials seem to fail authentication.'</span>.red)
      process.exit() <span class="hljs-comment">// eslint-disable-line no-process-exit</span>
    }
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\\o/ GitHub App credentials seem to successfully authenticate.'</span>.green)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>We started out with API wrapper authentication based on App credentials.
If we have an access token handy (from a key in our development <code>.env</code> file,
probably) now is the time to switch to it.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (credentials.accessToken) {
      github.authenticate({ type: <span class="hljs-string">'oauth'</span>, token: credentials.accessToken })
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Using stored access token'</span>.green, credentials.accessToken.cyan)
    }
  })
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="status-sending">Status sending</h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A thin wrapper on top of the GitHub API original call for
sending a status check to GitHub.  It just provides our usual
nicety of allowing <code>nwo</code> instead of individual <code>user</code> and <code>repo</code>.</p>
<p>This is used by the CI Service Core to report its progress and completion
to GitHub.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendStatusCheck</span> (<span class="hljs-params">params, callback</span>) </span>{
  <span class="hljs-keyword">var</span> nwo = params.nwo.split(<span class="hljs-string">'/'</span>)
  github.statuses.create({
    user: nwo[<span class="hljs-number">0</span>],
    repo: nwo[<span class="hljs-number">1</span>],
    sha: params.sha,
    state: params.state,
    description: params.description,
    context: params.context
  }, callback)
}

<span class="hljs-built_in">module</span>.exports = {
  checkToken: checkToken,
  configure: configure,
  createHook: createHook,
  exchangeAuthCodeForToken: exchangeAuthCodeForToken,
  getAuthorizationURL: getAuthorizationURL,
  getCommitsForPullRequest: getCommitsForPullRequest,
  getRepositories: getRepositories,
  getReviewURL: getReviewURL,
  isAuthenticated: isAuthenticated,
  loadAndVerifyWebhookEventPayload: loadAndVerifyWebhookEventPayload,
  SECRET_TOKEN: SECRET_TOKEN,
  sendStatusCheck: sendStatusCheck
}</div></div></div></div></body></html>