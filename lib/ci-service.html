<!DOCTYPE html><html lang="en"><head><title>lib/ci-service</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="lib/ci-service"><meta name="groc-project-path" content="lib/ci-service.js"><meta name="groc-github-url" content="https://github.com/deliciousinsights/oreilly-github-webhook-endpoint"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/deliciousinsights/oreilly-github-webhook-endpoint/blob/master/lib/ci-service.js">lib/ci-service.js</a></div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><h1 id="ci-service-core">CI Service Core</h1></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode">Strict mode</a> is always a good idea.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-pi">'use strict'</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="modules-we-need-in-this-file">Modules we need in this file</h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This loads both third-party (from <a href="http://npmjs.com/">npm</a>) and local stuff (paths starting with <code>./</code>).</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> <span class="hljs-keyword">async</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'async'</span>)
<span class="hljs-keyword">var</span> gitHubBridge = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./github-bridge'</span>)
<span class="hljs-keyword">var</span> flatten = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lodash.flatten'</span>)
<span class="hljs-keyword">var</span> invoke = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lodash.invoke'</span>)
<span class="hljs-keyword">var</span> pluck = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lodash.pluck'</span>)
<span class="hljs-keyword">var</span> uniq = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lodash.uniq'</span>)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="banned-buzzword-analysis">Banned buzzword analysis</h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Analyzes the messages for all commits involved in the Pull Request
described in <code>payload</code>, looking for banned buzzwords in the messages.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkForBannedBuzzwords</span> (<span class="hljs-params">payload, callback</span>) </span>{
  gitHubBridge.getCommitsForPullRequest({
    nwo: payload.pull_request.head.repo.full_name,
    number: payload.pull_request.number
  }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, commits</span>) </span>{
    <span class="hljs-keyword">if</span> (err) {
      <span class="hljs-keyword">return</span> callback(err)
    }

    <span class="hljs-keyword">var</span> banInfo = commits.reduce(detectBuzzwordsInCommit, {})
    callback(<span class="hljs-literal">null</span>, banInfo)
  })
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Computes the failure message, if any, derived from detailed
banned-buzzwords info.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">computeFailureMessage</span> (<span class="hljs-params">banInfo</span>) </span>{
  <span class="hljs-keyword">var</span> shas = <span class="hljs-built_in">Object</span>.keys(banInfo)
  <span class="hljs-keyword">if</span> (shas.length === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span>
  }

  <span class="hljs-keyword">var</span> abbrevs = invoke(shas, <span class="hljs-string">'slice'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>)
  <span class="hljs-keyword">var</span> data = shas.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sha</span>) </span>{ <span class="hljs-keyword">return</span> banInfo[sha] })
  <span class="hljs-keyword">var</span> authors = uniq(pluck(data, <span class="hljs-string">'author'</span>).sort())
  <span class="hljs-keyword">var</span> terms = uniq(invoke(flatten(pluck(data, <span class="hljs-string">'culprits'</span>)), <span class="hljs-string">'toLocaleLowerCase'</span>)).sort()
    .map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-string">'“'</span> + s + <span class="hljs-string">'”'</span> })

  <span class="hljs-keyword">var</span> who = authors.length &gt; <span class="hljs-number">1</span> ? toSentence(authors, <span class="hljs-number">3</span>, <span class="hljs-string">'authors including'</span>) : authors[<span class="hljs-number">0</span>]
  <span class="hljs-keyword">var</span> what = terms.length &gt; <span class="hljs-number">1</span> ? toSentence(terms, <span class="hljs-number">3</span>, <span class="hljs-string">'terms such as'</span>) : terms[<span class="hljs-number">0</span>]
  <span class="hljs-keyword">var</span> where = abbrevs.length &gt; <span class="hljs-number">1</span> ? toSentence(abbrevs, <span class="hljs-number">3</span>, <span class="hljs-string">'commits including'</span>) : abbrevs[<span class="hljs-number">0</span>]

  <span class="hljs-keyword">return</span> who + <span class="hljs-string">' went overboard with '</span> + what + <span class="hljs-string">' in '</span> + where
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Little helper function to turn an array of entities into a proper English
sentence, possibly explicitly truncated to a maximum amount of actual instances.
Assumes that <code>list</code> is 2+ items long.</p>
<p>For instance:</p>
<pre><code class="lang-js">toSentence([<span class="hljs-string">'Annie'</span>, <span class="hljs-string">'Bob'</span>]) <span class="hljs-comment">// =&gt; 'Annie and Bob'</span>
toSentence([<span class="hljs-string">'Annie'</span>, <span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Claire'</span>]) <span class="hljs-comment">// =&gt; 'Annie, Bob and Claire'</span>
toSentence([<span class="hljs-string">'Annie'</span>, <span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Claire'</span>, <span class="hljs-string">'Dave'</span>], <span class="hljs-number">2</span>, <span class="hljs-string">'people including'</span>)
<span class="hljs-comment">// =&gt; '4 people including Annie and Bob'</span></code></pre></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toSentence</span> (<span class="hljs-params">list, threshold, overflowPrefix</span>) </span>{
  <span class="hljs-keyword">var</span> result = list.slice(<span class="hljs-number">0</span>, threshold)
  result.splice(-<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, result.slice(-<span class="hljs-number">2</span>).join(<span class="hljs-string">' and '</span>))
  result = result.join(<span class="hljs-string">', '</span>)
  <span class="hljs-keyword">if</span> (list.length &gt; threshold) {
    result = list.length + <span class="hljs-string">' '</span> + overflowPrefix + <span class="hljs-string">' '</span> + result
  }

  <span class="hljs-keyword">return</span> result
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A regular expression describing the buzzwords (and their variations)
that our service will alert about.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> REGEX_BUZZWORDS = <span class="hljs-regexp">/utili[sz]e|synerg(?:y|i[sz]e)|growth hack(?:er|ing)?|leverag(?:e|ing)/i</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Little helper function, used inside the main detection algorithm,
contributing a commit&#39;s potential buzzword issues to a general accumulator.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">detectBuzzwordsInCommit</span> (<span class="hljs-params">acc, commit</span>) </span>{
  <span class="hljs-keyword">var</span> sha = commit.sha
  <span class="hljs-keyword">var</span> author = commit.author.login

  commit.commit.message.replace(REGEX_BUZZWORDS, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">culprit</span>) </span>{
    acc[sha] = acc[sha] || { author: author, culprits: [] }
    acc[sha].culprits.push(culprit)
  })

  <span class="hljs-keyword">return</span> acc
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="main-webhook-event-handler">Main webhook event handler</h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This is what the webhook&#39;s HTTP endpoint delegates to, once it&#39;s
established that the event matches what this CI service expects.</p>
<p>This is invoked asynchronously, outside the request/response cycle
(GitHub already got its 200 response by now).</p></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleEvent</span> (<span class="hljs-params">payload</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Processing PR payload…'</span>)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>We use <a href="https://github.com/caolan/async">Async.js</a> to ease this
workflow of asynchronous computations flowing into each other, in sequence.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">async</span>.waterfall([</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Step 1: send a pending status check to GitHub about this PR.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cb</span>) </span>{
      statusCheck(payload, <span class="hljs-string">'pending'</span>, <span class="hljs-string">'Reviewing commit messages for banned wording…'</span>, cb)
    },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Step 2: check for banned buzzwords (the core work of this CI service)
(this is async because we need to ask GitHub for details about the
commits involved in the PR).</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_, cb</span>) </span>{
      checkForBannedBuzzwords(payload, cb)
    },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Step 3: compute the failure message, if any, then notify either a
failure (buzzwords!) or a success (no frowned-upon buzzwords).</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">banInfo, cb</span>) </span>{
      <span class="hljs-keyword">var</span> message = computeFailureMessage(banInfo)
      <span class="hljs-keyword">if</span> (message) {
        statusCheck(payload, <span class="hljs-string">'failure'</span>, message, cb)
      } <span class="hljs-keyword">else</span> {
        statusCheck(payload, <span class="hljs-string">'success'</span>, <span class="hljs-string">'I like your commit messsages!'</span>, cb)
      }
    }
  ], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This is the final step of the async waterfall flow.  Errors at any
step of the way end up here, so we get a single, central error management.
As this is outside the HTTP request/response cycle, we just log on the
server&#39;s console.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (err) {
      <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'/!\\ Error while processing pull request commit:'</span>.red, <span class="hljs-built_in">String</span>(err).yellow)
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\\o/ Pull request commit successfully processed.'</span>.green)
    }
  })
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This is the &quot;context&quot; for our statuses, that help the GitHub users
identify our checks from those by other services (e.g. Travis, CodeClimate…)</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> STATUS_CONTEXT = <span class="hljs-string">'oreilly-github-api-demo/banned-buzzwords'</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Little helper function to send a status to GitHub for the given
pull request, using a consistent context.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">statusCheck</span> (<span class="hljs-params">payload, state, description, callback</span>) </span>{
  <span class="hljs-keyword">var</span> head = payload.pull_request.head
  gitHubBridge.sendStatusCheck({
    nwo: head.repo.full_name,
    sha: head.sha,
    state: state,
    context: STATUS_CONTEXT,
    description: description
  }, callback)
}

exports.handleEvent = handleEvent</div></div></div></div></body></html>